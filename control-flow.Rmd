# Control Flow

## if-else block

## cond: multiple if-else blocks

```elixir
cond do
  expression_1 -> do_1
  expression_2 -> do_2
  ...
end
```

## case: case when with pattern matching

```elixir
case expression do
  pattern_1 -> do_1
  pattern_2 -> do_2
    ...
end
```

```elixir
def max(a,b) do
  case a >= b do
    true -> a
    false -> b
  end
end
```

## with

## comprehensions

In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the for special form.

For example, we can map a list of integers into their squared values:

```elixir
iex> for n <- [1, 2, 3, 4], do: n * n
#> [1, 4, 9, 16]
```

A comprehension is made of three parts: **generators**, **filters**, and **collectables**.

```elixir
multiplication_table = for x <- 1..9, y <- 1..9, # generaotr
              x >= y, # filter
              into: %{} do # collectable
              {{x, y}, x*y}
end

multiplication_table
# %{
#   {8, 5} => 40,
#   {8, 6} => 48,
#   {5, 2} => 10,
#   {6, 5} => 30,
#   {1, 1} => 1,
#   {9, 6} => 54,
#   {4, 3} => 12,
#   ...
#   {9, 7} => 63,
#   {5, 1} => 5,
#   {2, 2} => 4,
#   {4, 4} => 16,
#   {7, 4} => 28,
#   {6, 3} => 18,
#   {5, 4} => 20,
#   {9, 9} => 81
# }
```