[{"path":"index.html","id":"preface","chapter":"1 Preface","heading":"1 Preface","text":"","code":""},{"path":"data-types.html","id":"data-types","chapter":"2 Data Types","heading":"2 Data Types","text":"","code":""},{"path":"data-types.html","id":"strings","chapter":"2 Data Types","heading":"2.1 Strings","text":"","code":""},{"path":"data-types.html","id":"tuples","chapter":"2 Data Types","heading":"2.2 Tuples","text":"Elixir tuples like arrays languages, storing elements contiguous memoery. means accessing tuple element index getting tuple size fast operation. Indexes start zero:also possible put element particular index tuple put_elem/3:Notice put_elem/3 returned new tuple. original tuple stored tuple variable modified. Like lists, tuples also immutable. Every operation tuple returns new tuple, never changes given one.","code":"iex> {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> tuple_size {:ok, \"hello\"}\n#> 2iex> tuple = {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> put_elem(tuple, 1, \"world\")\n#> {:ok, \"world\"}\niex> tuple\n#> {:ok, \"hello\"}"},{"path":"data-types.html","id":"linked-list","chapter":"2 Data Types","heading":"2.3 (Linked) List","text":"Elixir uses square brackets specify list values. Values can type:Lists stored memory linked lists, meaning element list holds value points following element end list reached. means accessing length list linear operation: need traverse whole list order figure size.Two lists can concatenated subtracted using ++/2 --/2 operators respectively:List operators never modify existing list. Concatenating removing elements list returns new list. say Elixir data structures immutable. One advantage immutability leads clearer code. can freely pass data around guarantee one mutate memory - transform .head list first element list tail remainder list. can retrieved functions hd/1 tl/1. Let’s assign list variable retrieve head tail:","code":"iex> [1, 2, true, 3]\n#> [1, 2, true, 3]\niex> length [1, 2, 3]\n#> 3iex> [1, 2, 3] ++ [4, 5, 6]\n#> [1, 2, 3, 4, 5, 6]\niex> [1, true, 2, false, 3, true] -- [true, false]\n#> [1, 2, 3, true]iex> list = [1, 2, 3]\niex> hd(list)\n#> 1\niex> tl(list)\n#> [2, 3]"},{"path":"data-types.html","id":"comparing-lists-and-tuples","chapter":"2 Data Types","heading":"2.3.1 Comparing Lists and Tuples","text":"Note lists Elixir actually linked lists, tuples “arrays” “list” languages contiguous elements.One common use case tuples use return extra information function. example, File.read/1 function can used read file contents. returns tuple:time, Elixir going guide right thing. example, elem/2 function access tuple item built-equivalent lists:counting elements data structure, Elixir also abides simple rule: function named size operation constant time (.e. value pre-calculated) length operation linear (.e. calculating length gets slower input grows). mnemonic, “length” “linear” start “l”.example, used 4 counting functions far: byte_size/1 (number bytes string), tuple_size/1 (tuple size), length/1 (list length) String.length/1 (number graphemes string). use byte_size get number bytes string – cheap operation. Retrieving number Unicode graphemes, hand, uses String.length, may expensive relies traversal entire string.","code":"iex> File.read(\"path/to/existing/file\")\n#> {:ok, \"... contents ...\"}\niex> File.read(\"path/to/unknown/file\")\n#> {:error, :enoent}iex> tuple = {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> elem(tuple, 1)\n#> \"hello\""},{"path":"data-types.html","id":"map","chapter":"2 Data Types","heading":"2.4 Map","text":"Whenever need key-value store, maps “go ” data structure Elixir. map created using %{} syntax:Compared keyword lists, can already see two differences:Maps allow value key.Maps allow value key.Maps’ keys follow ordering.Maps’ keys follow ordering.","code":"iex> map = %{:a => 1, 2 => :b}\n#> %{2 => :b, :a => 1}\niex> map[:a]\n#> 1\niex> map[2]\n#> :b\niex> map[:c]\n#> nil"},{"path":"data-types.html","id":"keyword-list","chapter":"2 Data Types","heading":"2.5 Keyword List","text":"Keyword lists lists 2-item tuples representation key-value data structure.Elixir supports special syntax defining lists: [key: value]. Underneath maps list tuples .e can use ++ add new values keyword list:Many useful functions available Keyword module (https://hexdocs.pm/ elixir/Keyword.html). example, can use bracket operator [] Keyword.get/2 fetch value keyDon’t let fool , though. ’re dealing list, complexity lookup operation O(n).Keyword lists often useful allowing clients pass arbitrary number \noptional arguments. example, result function IO.inspect, prints\nstring representation term console, can controlled providing addi-\ntional options keyword list:fact, pattern frequent Elixir allows omit square brackets last argument keyword list:Keyword lists important three special characteristics:Keys must atoms.Keys must atoms.Keys ordered, specified developer.Keys ordered, specified developer.Keys can given onceKeys can given onceFor example, keyword lists useful database queries can key different positions.using map instead, twice.","code":"[{:name, \"qiushi\"}, {:age, 1}][name: \"qiushi\", age: 1] # shortcut for [{:name, \"qiushi\"}, {:age, 1}]list = [{:a, 1}, {:b, 2}]\nlist ++ [c: 3]\n#> [a: 1, b: 2, c: 3]\n[a: 0] ++ list\n#> [a: 0, a: 1, b: 2]days = [monday: 1, tuesday: 2, wednesday: 3]\n\ndays[:monday]\n#> 1\nKeyword.get(days, :monday)\n#> 1\nKeyword.get(days, :noday)\n#> nilIO.inspect([100, 200, 300]) # Default behavior\n#> [100, 200, 300]\nIO.inspect([100, 200, 300], [width: 3]) # passing a keyword list as options\n#> [100,\n#> 200,\n#> 300]IO.inspect([100, 200, 300], width: 3, limit: 1)\n# pass the second argument as [width: 3, limit: 1]\n# not having a third argumentdb.find_user([where: age > 18, where: subscribed == true])"},{"path":"functions-and-modules.html","id":"functions-and-modules","chapter":"3 Functions and Modules","heading":"3 Functions and Modules","text":"","code":""},{"path":"functions-and-modules.html","id":"modules","chapter":"3 Functions and Modules","heading":"3.1 Modules","text":"","code":"defmodule MyModule do\n  def my_function(arg1, arg2) do\n    # ...\n  end\nend"},{"path":"functions-and-modules.html","id":"struct","chapter":"3 Functions and Modules","heading":"3.2 Struct","text":"","code":"defmodule Candidate do\n    defstruct [name: \"qiushi\", age: 18]\nend\n\nc = %Candidate{name: \"tom\"}\n#> %Candidate{name: \"tom\", age: 18}"},{"path":"functions-and-modules.html","id":"anoynmous-functions","chapter":"3 Functions and Modules","heading":"3.3 Anoynmous Functions","text":"","code":"square = fn x -> x * x end\nsquare.(5)\n#> 25"}]
