[{"path":"index.html","id":"preface","chapter":"1 Preface","heading":"1 Preface","text":"","code":""},{"path":"data-types.html","id":"data-types","chapter":"2 Data Types","heading":"2 Data Types","text":"","code":""},{"path":"data-types.html","id":"linked-list","chapter":"2 Data Types","heading":"2.1 (Linked) List","text":"","code":""},{"path":"data-types.html","id":"map","chapter":"2 Data Types","heading":"2.2 Map","text":"Whenever need key-value store, maps “go ” data structure Elixir. map created using %{} syntax:Compared keyword lists, can already see two differences:Maps allow value key.Maps allow value key.Maps’ keys follow ordering.Maps’ keys follow ordering.","code":"iex> map = %{:a => 1, 2 => :b}\n%{2 => :b, :a => 1}\niex> map[:a]\n1\niex> map[2]\n:b\niex> map[:c]\nnil"},{"path":"data-types.html","id":"keyword-list","chapter":"2 Data Types","heading":"2.3 Keyword List","text":"Keyword lists lists 2-item tuples representation key-value data structure.Elixir supports special syntax defining lists: [key: value]. Underneath maps list tuples .e can use ++ add new values keyword list:Many useful functions available Keyword module (https://hexdocs.pm/ elixir/Keyword.html). example, can use bracket operator [] Keyword.get/2 fetch value keyDon’t let fool , though. ’re dealing list, complexity lookup operation O(n).Keyword lists often useful allowing clients pass arbitrary number \noptional arguments. example, result function IO.inspect, prints\nstring representation term console, can controlled providing addi-\ntional options keyword list:fact, pattern frequent Elixir allows omit square brackets last argument keyword list:Keyword lists important three special characteristics:Keys must atoms.Keys must atoms.Keys ordered, specified developer.Keys ordered, specified developer.Keys can given onceKeys can given onceFor example, keyword lists useful database queries can key different positions.using map instead, twice.","code":"[{:name, \"qiushi\"}, {:age, 1}][name: \"qiushi\", age: 1] # shortcut for [{:name, \"qiushi\"}, {:age, 1}]list = [{:a, 1}, {:b, 2}]\nlist ++ [c: 3]\n#> [a: 1, b: 2, c: 3]\n[a: 0] ++ list\n#> [a: 0, a: 1, b: 2]days = [monday: 1, tuesday: 2, wednesday: 3]\n\ndays[:monday]\n#> 1\nKeyword.get(days, :monday)\n#> 1\nKeyword.get(days, :noday)\n#> niliex(6)> IO.inspect([100, 200, 300]) # Default behavior\n#> [100, 200, 300]\nIO.inspect([100, 200, 300], [width: 3]) # passing a keyword list as options\n#> [100,\n#> 200,\n#> 300]IO.inspect([100, 200, 300], width: 3, limit: 1)\n# pass the second argument as [width: 3, limit: 1]\n# not having a third argumentdb.find_user([where: age > 18, where: subscribed == true])"}]
