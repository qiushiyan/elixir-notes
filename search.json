[{"path":"index.html","id":"preface","chapter":"1 Preface","heading":"1 Preface","text":"","code":""},{"path":"data-types.html","id":"data-types","chapter":"2 Data Types","heading":"2 Data Types","text":"","code":""},{"path":"data-types.html","id":"strings","chapter":"2 Data Types","heading":"2.1 Strings","text":"","code":""},{"path":"data-types.html","id":"tuples","chapter":"2 Data Types","heading":"2.2 Tuples","text":"Elixir tuples like arrays languages, storing elements contiguous memoery. means accessing tuple element index getting tuple size fast operation. Indexes start zero:also possible put element particular index tuple put_elem/3:Notice put_elem/3 returned new tuple. original tuple stored tuple variable modified. Like lists, tuples also immutable. Every operation tuple returns new tuple, never changes given one.","code":"iex> {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> tuple_size {:ok, \"hello\"}\n#> 2iex> tuple = {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> put_elem(tuple, 1, \"world\")\n#> {:ok, \"world\"}\niex> tuple\n#> {:ok, \"hello\"}"},{"path":"data-types.html","id":"linked-list","chapter":"2 Data Types","heading":"2.3 (Linked) List","text":"Elixir uses square brackets specify list values. Values can type:Lists stored memory linked lists, meaning element list holds value points following element end list reached. means accessing length list linear operation: need traverse whole list order figure size.Two lists can concatenated subtracted using ++/2 --/2 operators respectively:List operators never modify existing list. Concatenating removing elements list returns new list. say Elixir data structures immutable. One advantage immutability leads clearer code. can freely pass data around guarantee one mutate memory - transform .head list first element list tail remainder list. can retrieved functions hd/1 tl/1. Let’s assign list variable retrieve head tail:","code":"iex> [1, 2, true, 3]\n#> [1, 2, true, 3]\niex> length [1, 2, 3]\n#> 3iex> [1, 2, 3] ++ [4, 5, 6]\n#> [1, 2, 3, 4, 5, 6]\niex> [1, true, 2, false, 3, true] -- [true, false]\n#> [1, 2, 3, true]iex> list = [1, 2, 3]\niex> hd(list)\n#> 1\niex> tl(list)\n#> [2, 3]"},{"path":"data-types.html","id":"comparing-lists-and-tuples","chapter":"2 Data Types","heading":"2.3.1 Comparing Lists and Tuples","text":"Note lists Elixir actually linked lists, tuples “arrays” “list” languages contiguous elements.One common use case tuples use return extra information function. example, File.read/1 function can used read file contents. returns tuple:time, Elixir going guide right thing. example, elem/2 function access tuple item built-equivalent lists:counting elements data structure, Elixir also abides simple rule: function named size operation constant time (.e. value pre-calculated) length operation linear (.e. calculating length gets slower input grows). mnemonic, “length” “linear” start “l”.example, used 4 counting functions far: byte_size/1 (number bytes string), tuple_size/1 (tuple size), length/1 (list length) String.length/1 (number graphemes string). use byte_size get number bytes string – cheap operation. Retrieving number Unicode graphemes, hand, uses String.length, may expensive relies traversal entire string.","code":"iex> File.read(\"path/to/existing/file\")\n#> {:ok, \"... contents ...\"}\niex> File.read(\"path/to/unknown/file\")\n#> {:error, :enoent}iex> tuple = {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> elem(tuple, 1)\n#> \"hello\""},{"path":"data-types.html","id":"map","chapter":"2 Data Types","heading":"2.4 Map","text":"Whenever need key-value store, maps “go ” data structure Elixir. map created using %{} syntax:Compared keyword lists, can already see two differences:Maps allow value key.Maps allow value key.Maps’ keys follow ordering.Maps’ keys follow ordering.Maps following syntax updating key’s value:","code":"iex> map = %{:a => 1, 2 => :b}\n#> %{2 => :b, :a => 1}\niex> map[:a]\n#> 1\niex> map[2]\n#> :b\niex> map[:c]\n#> nilmap = %{a: 1, b: 2}\n%{map | a: 3}\n#> %{a: 3, b: 2}"},{"path":"data-types.html","id":"keyword-list","chapter":"2 Data Types","heading":"2.5 Keyword List","text":"Keyword lists lists 2-item tuples representation key-value data structure.Elixir supports special syntax defining lists: [key: value]. Underneath maps list tuples .e can use ++ add new values keyword list:Many useful functions available Keyword module (https://hexdocs.pm/ elixir/Keyword.html). example, can use bracket operator [] Keyword.get/2 fetch value keyDon’t let fool , though. ’re dealing list, complexity lookup operation O(n).Keyword lists often useful allowing clients pass arbitrary number \noptional arguments. example, result function IO.inspect, prints\nstring representation term console, can controlled providing addi-\ntional options keyword list:fact, pattern frequent Elixir allows omit square brackets last argument keyword list:Keyword lists important three special characteristics:Keys must atoms.Keys must atoms.Keys ordered, specified developer.Keys ordered, specified developer.Keys can given onceKeys can given onceFor example, keyword lists useful database queries can key different positions.using map instead, twice.","code":"[{:name, \"qiushi\"}, {:age, 1}][name: \"qiushi\", age: 1] # shortcut for [{:name, \"qiushi\"}, {:age, 1}]list = [{:a, 1}, {:b, 2}]\nlist ++ [c: 3]\n#> [a: 1, b: 2, c: 3]\n[a: 0] ++ list\n#> [a: 0, a: 1, b: 2]days = [monday: 1, tuesday: 2, wednesday: 3]\n\ndays[:monday]\n#> 1\nKeyword.get(days, :monday)\n#> 1\nKeyword.get(days, :noday)\n#> nilIO.inspect([100, 200, 300]) # Default behavior\n#> [100, 200, 300]\nIO.inspect([100, 200, 300], [width: 3]) # passing a keyword list as options\n#> [100,\n#> 200,\n#> 300]IO.inspect([100, 200, 300], width: 3, limit: 1)\n# pass the second argument as [width: 3, limit: 1]\n# not having a third argumentdb.find_user([where: age > 18, where: subscribed == true])"},{"path":"functions-and-modules.html","id":"functions-and-modules","chapter":"3 Functions and Modules","heading":"3 Functions and Modules","text":"","code":""},{"path":"functions-and-modules.html","id":"modules","chapter":"3 Functions and Modules","heading":"3.1 Modules","text":"","code":"defmodule MyModule do\n  def my_function(arg1, arg2) do\n    # ...\n  end\nend"},{"path":"functions-and-modules.html","id":"struct","chapter":"3 Functions and Modules","heading":"3.2 Struct","text":"","code":"defmodule Candidate do\n    defstruct [name: \"qiushi\", age: 18]\nend\n\nc = %Candidate{name: \"tom\"}\n#> %Candidate{name: \"tom\", age: 18}"},{"path":"functions-and-modules.html","id":"anoynmous-functions","chapter":"3 Functions and Modules","heading":"3.3 Anoynmous Functions","text":"","code":"square = fn x -> x * x end\nsquare.(5)\n#> 25"},{"path":"enum-module.html","id":"enum-module","chapter":"4 Enum Module","heading":"4 Enum Module","text":"Use capture operator & shortcut, takes full function qualifier — module name, function name, arity — turns function lambda can assigned variable. can use capture operator simplify call Enum.:","code":"Enum.each(\n    [1, 2, 3],\n    fn (x) -> IO.puts(x) end\n)\n#> 1\n#> 2\n#> 3\n#> :okEnum.each(\n    [1, 2, 3],\n    &IO.puts/1\n)"},{"path":"pattern-matching.html","id":"pattern-matching","chapter":"5 Pattern Matching","heading":"5 Pattern Matching","text":"","code":""},{"path":"pattern-matching.html","id":"matching-tuples-lists-maps-and-strings","chapter":"5 Pattern Matching","heading":"5.1 Matching Tuples, Lists, Maps and Strings","text":"Matching tuplesNested matchMatching listsMatching lists often done relying recursive nature. Recall non-empty list recursive structure can expressed form [head | tail]. can use pattern matching put two elements separate variables:need one element [head, tail] pair, can use anonymous variable. ’s inefficient way calculating smallest element list:Match mapsOf course, match fail pattern contains key ’s matched term:Match stringsOccasionally, ’ll need match contents variable. pur- pose, pin operator (^) provided.","code":"{date, time} = :calendar.local_time()\n\ndate\n#> {2022, 1, 2}\ntime\n#> {14, 44, 35}{_, {hour, _, _}} = :calendar.local_time()\nhour\n#> 14[first, second, third] = [1, 2, 3]iex(3)> [head | tail] = [1, 2, 3]\n#> [1, 2, 3]\niex(4)> head\n#> 1\niex(5)> tail\n#> [2, 3]iex(6)> [min | _] = Enum.sort([3, 2, 1])\niex(7)> min\n#> 1%{age: age2} =  %{name: \"Bob\", age: 25}\nage2\n#> 25%{age: age, works_at: works_at} = %{name: \"Bob\", age: 25}\n#> ** (MatchError) no match of right hand side valueiex(13)> <<b1, b2, b3>> = \"ABC\"\n#> \"ABC\"\niex(13)> b1\n#> 65\niex(14)> b2\n#> 66\niex(15)> b3\n#> 67command = \"ping www.google.com\"\n\"ping \" <> url = command\n\nurl\n#> www.google.comiex(7)> expected_name = \"Bob\"\n\n# Matches to the content of the variable expected_name\niex(8)> {^expected_name, _} = {\"Bob\", 25}\n#> {\"Bob\", 25}\n\niex(9)> {^expected_name, _} = {\"Alice\", 30}\n#> ** (MatchError) no match of right hand side value: {\"Alice\", 30}"},{"path":"pattern-matching.html","id":"multiclause-functions","chapter":"5 Pattern Matching","heading":"5.2 Multiclause functions","text":"lixir allows overload function specifying multiple clauses. clause func- tion definition specified def construct. provide multiple definitions function arity, ’s said function multiple clauses.Let’s see action. Extending previous example, let’s say need develop Geometry module can handle various shapes. ’ll represent shapes tuples use first element tuple indicate shape represents:","code":"defmodule Geometry do\n    def area({:rectangle, a, b}) do\n        a* b\n    end\n\n    def area({:square, a}) do\n        a* a\n    end\n\n    def area({:circle, r}) do\n        r * r * 3.14\n    end\nend"},{"path":"project-management-with-mix.html","id":"project-management-with-mix","chapter":"6 Project Management with Mix","heading":"6 Project Management with Mix","text":"","code":""}]
