[{"path":"index.html","id":"preface","chapter":"1 Preface","heading":"1 Preface","text":"","code":""},{"path":"index.html","id":"the-beam-virtual-machine","chapter":"1 Preface","heading":"1.1 The Beam Virtual Machine","text":"","code":""},{"path":"index.html","id":"concurrency-in-elixir","chapter":"1 Preface","heading":"1.2 Concurrency in Elixir","text":"","code":""},{"path":"data-types.html","id":"data-types","chapter":"2 Data Types","heading":"2 Data Types","text":"","code":""},{"path":"data-types.html","id":"strings","chapter":"2 Data Types","heading":"2.1 Strings","text":"","code":""},{"path":"data-types.html","id":"tuples","chapter":"2 Data Types","heading":"2.2 Tuples","text":"Elixir tuples like arrays languages, storing elements contiguous memoery. means accessing tuple element index getting tuple size fast operation. Indexes start zero:also possible put element particular index tuple put_elem/3:Notice put_elem/3 returned new tuple. original tuple stored tuple variable modified. Like lists, tuples also immutable. Every operation tuple returns new tuple, never changes given one.","code":"iex> {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> tuple_size {:ok, \"hello\"}\n#> 2iex> tuple = {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> put_elem(tuple, 1, \"world\")\n#> {:ok, \"world\"}\niex> tuple\n#> {:ok, \"hello\"}"},{"path":"data-types.html","id":"linked-list","chapter":"2 Data Types","heading":"2.3 (Linked) List","text":"Elixir uses square brackets specify list values. Values can type:Lists stored memory linked lists, meaning element list holds value points following element end list reached. means accessing length list linear operation: need traverse whole list order figure size.Two lists can concatenated subtracted using ++/2 --/2 operators respectively:List operators never modify existing list. Concatenating removing elements list returns new list. say Elixir data structures immutable. One advantage immutability leads clearer code. can freely pass data around guarantee one mutate memory - transform .head list first element list tail remainder list. can retrieved functions hd/1 tl/1. Let’s assign list variable retrieve head tail:","code":"iex> [1, 2, true, 3]\n#> [1, 2, true, 3]\niex> length [1, 2, 3]\n#> 3iex> [1, 2, 3] ++ [4, 5, 6]\n#> [1, 2, 3, 4, 5, 6]\niex> [1, true, 2, false, 3, true] -- [true, false]\n#> [1, 2, 3, true]iex> list = [1, 2, 3]\niex> hd(list)\n#> 1\niex> tl(list)\n#> [2, 3]"},{"path":"data-types.html","id":"comparing-lists-and-tuples","chapter":"2 Data Types","heading":"2.3.1 Comparing Lists and Tuples","text":"Note lists Elixir actually linked lists, tuples “arrays” “list” languages contiguous elements.One common use case tuples use return extra information function. example, File.read/1 function can used read file contents. returns tuple:time, Elixir going guide right thing. example, elem/2 function access tuple item built-equivalent lists:counting elements data structure, Elixir also abides simple rule: function named size operation constant time (.e. value pre-calculated) length operation linear (.e. calculating length gets slower input grows). mnemonic, “length” “linear” start “l”.example, used 4 counting functions far: byte_size/1 (number bytes string), tuple_size/1 (tuple size), length/1 (list length) String.length/1 (number graphemes string). use byte_size get number bytes string – cheap operation. Retrieving number Unicode graphemes, hand, uses String.length, may expensive relies traversal entire string.","code":"iex> File.read(\"path/to/existing/file\")\n#> {:ok, \"... contents ...\"}\niex> File.read(\"path/to/unknown/file\")\n#> {:error, :enoent}iex> tuple = {:ok, \"hello\"}\n#> {:ok, \"hello\"}\niex> elem(tuple, 1)\n#> \"hello\""},{"path":"data-types.html","id":"map","chapter":"2 Data Types","heading":"2.4 Map","text":"Whenever need key-value store, maps “go ” data structure Elixir. map created using %{} syntax:Compared keyword lists, can already see two differences:Maps allow value key.Maps allow value key.Maps’ keys follow ordering.Maps’ keys follow ordering.Maps (well structs) shortcut syntax updating key’s value:","code":"iex> map = %{:a => 1, 2 => :b}\n#> %{2 => :b, :a => 1}\niex> map[:a]\n#> 1\niex> map[2]\n#> :b\niex> map[:c]\n#> nilmap = %{a: 1, b: 2}\n%{map | a: 3}\n#> %{a: 3, b: 2}"},{"path":"data-types.html","id":"map-utilities","chapter":"2 Data Types","heading":"2.4.1 Map Utilities","text":"get key’s valueputs given value key map (alternative | syntax)Updates key map given function.key present map existing value passed fun \nresult used updated value key. key present map,\ndefault inserted value key. default value passed\nupdate function.","code":"Map.get(map, key, default_value)Map.put(map, key, value)Map.update(map, key, default, fun)"},{"path":"data-types.html","id":"keyword-list","chapter":"2 Data Types","heading":"2.5 Keyword List","text":"Keyword lists lists 2-item tuples representation key-value data structure.Elixir supports special syntax defining lists: [key: value]. Underneath maps list tuples .e can use ++ add new values keyword list:Many useful functions available Keyword module (https://hexdocs.pm/ elixir/Keyword.html). example, can use bracket operator [] Keyword.get/2 fetch value keyDon’t let fool , though. ’re dealing list, complexity lookup operation O(n).Keyword lists often useful allowing clients pass arbitrary number \noptional arguments. example, result function IO.inspect, prints\nstring representation term console, can controlled providing addi-\ntional options keyword list:fact, pattern frequent Elixir allows omit square brackets last argument keyword list:Keyword lists important three special characteristics:Keys must atoms.Keys must atoms.Keys ordered, specified developer.Keys ordered, specified developer.Keys can given onceKeys can given onceFor example, keyword lists useful database queries can key different positions.using map instead, twice.","code":"[{:name, \"qiushi\"}, {:age, 1}][name: \"qiushi\", age: 1] # shortcut for [{:name, \"qiushi\"}, {:age, 1}]list = [{:a, 1}, {:b, 2}]\nlist ++ [c: 3]\n#> [a: 1, b: 2, c: 3]\n[a: 0] ++ list\n#> [a: 0, a: 1, b: 2]days = [monday: 1, tuesday: 2, wednesday: 3]\n\ndays[:monday]\n#> 1\nKeyword.get(days, :monday)\n#> 1\nKeyword.get(days, :noday)\n#> nilIO.inspect([100, 200, 300]) # Default behavior\n#> [100, 200, 300]\nIO.inspect([100, 200, 300], [width: 3]) # passing a keyword list as options\n#> [100,\n#> 200,\n#> 300]IO.inspect([100, 200, 300], width: 3, limit: 1)\n# pass the second argument as [width: 3, limit: 1]\n# not having a third argumentdb.find_user([where: age > 18, where: subscribed == true])"},{"path":"pattern-matching.html","id":"pattern-matching","chapter":"3 Pattern Matching","heading":"3 Pattern Matching","text":"","code":""},{"path":"pattern-matching.html","id":"matching-tuples-lists-maps-and-strings","chapter":"3 Pattern Matching","heading":"3.1 Matching Tuples, Lists, Maps and Strings","text":"Matching tuplesNested matchMatching listsMatching lists often done relying recursive nature. Recall non-empty list recursive structure can expressed form [head | tail]. can use pattern matching put two elements separate variables:need one element [head, tail] pair, can use anonymous variable. ’s inefficient way calculating smallest element list:Match mapsOf course, match fail pattern contains key ’s matched term:Match stringsOccasionally, ’ll need match contents variable. pur- pose, pin operator (^) provided.","code":"{date, time} = :calendar.local_time()\n\ndate\n#> {2022, 1, 2}\ntime\n#> {14, 44, 35}{_, {hour, _, _}} = :calendar.local_time()\nhour\n#> 14[first, second, third] = [1, 2, 3]iex(3)> [head | tail] = [1, 2, 3]\n#> [1, 2, 3]\niex(4)> head\n#> 1\niex(5)> tail\n#> [2, 3]iex(6)> [min | _] = Enum.sort([3, 2, 1])\niex(7)> min\n#> 1%{age: age2} =  %{name: \"Bob\", age: 25}\nage2\n#> 25%{age: age, works_at: works_at} = %{name: \"Bob\", age: 25}\n#> ** (MatchError) no match of right hand side valueiex(13)> <<b1, b2, b3>> = \"ABC\"\n#> \"ABC\"\niex(13)> b1\n#> 65\niex(14)> b2\n#> 66\niex(15)> b3\n#> 67command = \"ping www.google.com\"\n\"ping \" <> url = command\n\nurl\n#> www.google.comiex(7)> expected_name = \"Bob\"\n\n# Matches to the content of the variable expected_name\niex(8)> {^expected_name, _} = {\"Bob\", 25}\n#> {\"Bob\", 25}\n\niex(9)> {^expected_name, _} = {\"Alice\", 30}\n#> ** (MatchError) no match of right hand side value: {\"Alice\", 30}"},{"path":"pattern-matching.html","id":"multiclause-functions","chapter":"3 Pattern Matching","heading":"3.2 Multiclause functions","text":"pattern-matching mechanism used specification function arguments. Recall basic function definition:argument specifiers arg1 arg2 patterns, can use standard matching techniques.example, geometry manipulation, can represent rectangle tuple, {, b}, containing rectangle’s sides. following listing shows function calculates rectangle’s area.pattern matching function arguments, Elixir allows overload function specifying multiple clauses. clause function definition specified def construct. provide multiple definitions function arity, ’s said function multiple clauses.Let’s see action. Extending previous example, let’s say need develop Geometry module can handle various shapes. ’ll represent shapes tuples use first element tuple indicate shape represents:Sometimes ’ll want function return term indicating failure, rather raising error. can introduce default clause always matches. Let’s \narea function. next listing adds final clause handles invalid input.none first three clauses match, final clause called. variable pattern always matches corresponding term. case, return two-element tuple {:error, reason}, indicate something gone wrong.","code":"def my_fun(arg1, arg2) do\n  ...\nenddefmodule Rectangle do\n  def area( { a, b } ) do\n    a* b\nend\nend\n\nRectangle.area({2, 3})\n#> 6defmodule Geometry do\n    def area({:rectangle, a, b}) do\n        a* b\n    end\n\n    def area({:square, a}) do\n        a* a\n    end\n\n    def area({:circle, r}) do\n        r * r * 3.14\n    end\nendiex(1)> Geometry.area({:rectangle, 4, 5})\n#> 20\niex(2)> Geometry.area({:square, 5})\n#> 25\niex(3)> Geometry.area({:circle, 4})\n#> 50.24defmodule Geometry do\n    def area({:rectangle, a, b}) do\n        a* b\n    end\n\n    def area({:square, a}) do\n        a* a\n    end\n\n    def area({:circle, r}) do\n        r * r * 3.14\n    end\n\n    def area(unknown) do\n        {:error, {:unknown, unknown}}\n    end\nend"},{"path":"pattern-matching.html","id":"guards","chapter":"3 Pattern Matching","heading":"3.3 Guards","text":"Let’s say want write function accepts number returns atom :negative, :zero, :positive, depending number’s value. isn’t possi- ble simple pattern matching ’ve seen far. Elixir gives solution form guards.Guards extension basic pattern-matching mechanism. allow state additional broader expectations must satisfied entire pattern match.guard can specified providing clause arguments list. best illustrated example. following code tests whether given number positive, negative, zero.guard logical expression places conditions clause. first clause called pass negative number, last one called pass positive number, demonstrated shell session:Surprisingly enough, calling function non-number yields strange results:explanation lies fact Elixir terms can compared operators < d >, even ’re type. case, type ordering determines result:number smaller type, TestNum.test/1 always returns :positive provide non-number. fix , extend guard testing whether argument number, illustrated next.code uses function Kernel.is_number/1 test whether argument number. Now TestNum.test/1 raises error pass non-number:function body contains one line, possible exclude end keyword empty guardNotice comma behind foo(term) represents empty, catch-guard.","code":"defmodule TestNum do\n        def test(x) when x < 0, do\n           :negative\n        end\n\n        def test(0), do:\n            :zero\n        end\n\n        def test(x) when x > 0, do\n           :positive\n        end\nendiex(1)> TestNum.test(-1)\n#> :negative\niex(2)> TestNum.test(0)\n#> :zero\niex(3)> TestNum.test(1)\n#> :positiveiex(4)> TestNum.test(:not_a_number)\n#> :positivenumber < atom < reference < fun < port < pid < tuple < map < list < bitstring (binary)defmodule TestNum do\n  def test(x) when is_number(x) and x < 0 do\n    :negative\n  end\n\n  def test(0), do: zero\n\n  def test(x) when is_number(x) and x > 0 do\n    :positive\n  end\nendiex(1)> TestNum.test(-1)\n#> :negative\niex(2)> TestNum.test(:not_a_number)\n#> ** (FunctionClauseError) no function clause matching in TestNum.test/1def foo(term), do: term"},{"path":"pattern-matching.html","id":"lambda-functions","chapter":"3 Pattern Matching","heading":"3.3.1 Lambda functions","text":"can also lambda functions guards.","code":"test_num =\n    fn\n        x when is_number(x) and x < 0 -> :negative\n\n        0 -> :zero\n\n        x when is_number(x) and x > 0 -> :positive\n    end"},{"path":"functions-and-modules.html","id":"functions-and-modules","chapter":"4 Functions and Modules","heading":"4 Functions and Modules","text":"","code":""},{"path":"functions-and-modules.html","id":"modules","chapter":"4 Functions and Modules","heading":"4.1 Modules","text":"","code":"defmodule MyModule do\n  def my_function(arg1, arg2) do\n    # ...\n  end\nend"},{"path":"functions-and-modules.html","id":"struct","chapter":"4 Functions and Modules","heading":"4.2 Struct","text":"","code":"defmodule Candidate do\n    defstruct [name: \"qiushi\", age: 18]\nend\n\nc = %Candidate{name: \"tom\"}\n#> %Candidate{name: \"tom\", age: 18}"},{"path":"functions-and-modules.html","id":"anoynmous-functions","chapter":"4 Functions and Modules","heading":"4.3 Anoynmous Functions","text":"","code":"square = fn x -> x * x end\nsquare.(5)\n#> 25"},{"path":"functions-and-modules.html","id":"anoynmous-functions-with-pattern-matching","chapter":"4 Functions and Modules","heading":"4.3.1 Anoynmous Functions with Pattern Matching","text":"","code":"logo_file = fn\n  (:democratic) -> \"donkey.png\"\n  (:republican) -> \"elephant.png\"\n  (:green) -> \"flower.png\"\n  (:other) -> \"other.png\"\nend\n\nlogo_file.(:green)\n#> \"flower.png\""},{"path":"functions-and-modules.html","id":"module-attributes","chapter":"4 Functions and Modules","heading":"4.4 Module attributes","text":"Module attributes computed compile time.","code":"defmodule Mascot do\n  @mascots %{\n    democratic: \"monkey\",\n    republican: \"elephant\",\n    green: \"plant\",\n  }\n\n  @parties Map.keys(@mascots)\n\n  def mascot(party) do\n    @mascots[party]\n  end\n\n\n  def logo(party, size) when party in @parties do\n    m = mascot(party)\n    do_logo_size(m, size)\n  end\n\n  def logo(party, size) do\n    {:error, :unknown_party}\n  end\n\n  defp do_logo_size(mascot, :small), do: \"#{mascot}_small.png\"\n  defp do_logo_size(mascot, :normal), do: \"#{mascot}_normal.png\"\n  defp do_logo_size(mascot, :large), do: \"#{mascot}_large.png\"\n  defp do_logo_size(mascot, unknown), do: {:error, :unknown_size}\n\nend"},{"path":"functions-and-modules.html","id":"protocols","chapter":"4 Functions and Modules","heading":"4.5 Protocols","text":"","code":""},{"path":"functions-and-modules.html","id":"use-import-and-alias","chapter":"4 Functions and Modules","heading":"4.6 Use, Import and Alias","text":"","code":""},{"path":"functions-and-modules.html","id":"import","chapter":"4 Functions and Modules","heading":"4.6.1 Import","text":"want import functions rather aliasing module can use import:default functions macros imported can filter using ::except options.import specific functions macros, must provide name/arity pairs ::except. Let’s start importing last/1 function:import everything except last/1 try functions :addition name/arity pairs two special atoms, :functions :macros, import functions macros respectively:import List, : :functions\nimport List, : :macros","code":"iex> import List\n#> nil\niex> last([1, 2, 3])\n#> 3iex> import List, only: [last: 1]\niex> first([1, 2, 3])\n#> ** (CompileError) iex:13: undefined function first/1\niex> last([1, 2, 3])\n#> 3iex> import List, except: [last: 1]\niex> first([1, 2, 3])\n#> 1\niex> last([1, 2, 3])\n#> ** (CompileError) iex:3: undefined function last/1"},{"path":"functions-and-modules.html","id":"alias","chapter":"4 Functions and Modules","heading":"4.6.2 Alias","text":"Allows us alias module names; used quite frequently Elixir code:Without aliasIf ’s conflict two aliases just wish alias different name entirely, can use :option:’s even possible alias multiple modules :","code":"defmodule Sayings.Greetings do\n  def basic(name), do: \"Hi, #{name}\"\nend\n\ndefmodule Example do\n  alias Sayings.Greetings\n\n  def greeting(name), do: Greetings.basic(name)\nenddefmodule Example do\n  def greeting(name), do: Sayings.Greetings.basic(name)\nenddefmodule Example do\n  alias Sayings.Greetings, as: Hi\n\n  def print_message(name), do: Hi.basic(name)\nenddefmodule Example do\n  alias Sayings.{Greetings, Farewells}\nend"},{"path":"enum-module.html","id":"enum-module","chapter":"5 Enum Module","heading":"5 Enum Module","text":"Use capture operator & shortcut, takes full function qualifier — module name, function name, arity — turns function lambda can assigned variable. can use capture operator simplify call Enum.:","code":"Enum.each(\n    [1, 2, 3],\n    fn (x) -> IO.puts(x) end\n)\n#> 1\n#> 2\n#> 3\n#> :okEnum.each(\n    [1, 2, 3],\n    &IO.puts/1\n)"},{"path":"control-flow.html","id":"control-flow","chapter":"6 Control Flow","heading":"6 Control Flow","text":"","code":""},{"path":"control-flow.html","id":"if-else-block","chapter":"6 Control Flow","heading":"6.1 if-else block","text":"condense one line (notice comma , condition, similar oneline function def fun(), : expresion)","code":"if condition do\n    ...\nelse\n    ...\nendif condition, do: true_value, else: false_value"},{"path":"control-flow.html","id":"cond-multiple-if-else-blocks","chapter":"6 Control Flow","heading":"6.2 cond: multiple if-else blocks","text":"","code":"cond do\n  expression_1 -> return_1\n  expression_2 -> return_2\n  ...\nend"},{"path":"control-flow.html","id":"case-case-when-with-pattern-matching","chapter":"6 Control Flow","heading":"6.3 case: case when with pattern matching","text":"","code":"case expression do\n  pattern_1 -> return_1\n  pattern_2 -> return_2\n    ...\nenddef max(a,b) do\n  case a >= b do\n    true -> a\n    false -> b\n  end\nend"},{"path":"control-flow.html","id":"with-combine-multiple-clauses","chapter":"6 Control Flow","heading":"6.4 with: combine multiple clauses","text":"Used combine matching clauses. Let’s start example:clauses match, block executed, returning result. Otherwise chain aborted non-matched value returned:Alternative way using comprehension pattern matching","code":"opts = %{width: 10, height: 15}\nwith {:ok, width} <- Map.fetch(opts, :width),\n     {:ok, height} <- Map.fetch(opts, :height) do\n  {:ok, width * height}\nend\n#> {:ok, 150}opts = %{width: 10}\nwith {:ok, width} <- Map.fetch(opts, :width),\n     {:ok, height} <- Map.fetch(opts, :height) do\n  {:ok, width * height}\nend\n#> :errorfor %{width: width, height: height} <- [opts] do\n  width * height\nend\n#> [150]"},{"path":"control-flow.html","id":"comprehensions","chapter":"6 Control Flow","heading":"6.5 comprehensions","text":"Elixir, common loop Enumerable, often filtering results mapping values another list. Comprehensions syntactic sugar constructs: group common tasks special form.example, can map list integers squared values:comprehension made three parts: generators, filters, collectables. Comprension useful multiple enumerables involved Enum.map can’t job.can see, multiple generators used, result cartesian product enumerables.can also use pattern matching generator filtering. left side generator match, -loop just ignore value continue process.","code":"iex> for n <- [1, 2, 3, 4], do: n * n\n#> [1, 4, 9, 16]multiplication_table = for x <- 1..9, y <- 1..9, # generaotr\n              x >= y, # filter\n              into: %{} do # collectable\n              {{x, y}, x*y}\nend\n\nmultiplication_table\n# %{\n#   {8, 5} => 40,\n#   {8, 6} => 48,\n#   {5, 2} => 10,\n#   {6, 5} => 30,\n#   {1, 1} => 1,\n#   {9, 6} => 54,\n#   {4, 3} => 12,\n#   ...\n#   {9, 7} => 63,\n#   {5, 1} => 5,\n#   {2, 2} => 4,\n#   {4, 4} => 16,\n#   {7, 4} => 28,\n#   {6, 3} => 18,\n#   {5, 4} => 20,\n#   {9, 9} => 81\n# }names = ~w[James John Patricia]\nsurnames = ~w[Johnson Smith Williams]\n\nfor name <- names,\n    surname <- surnames do\n  \"#{name} #{surname}\"\nend\n# => [\n# =>   \"James Johnson\",\n# =>   \"James Smith\",\n# =>   \"James Williams\",\n# =>   \"John Johnson\",\n# =>   \"John Smith\",\n# =>   \"John Williams\",\n# =>   \"Patricia Johnson\",\n# =>   \"Patricia Smith\",\n# =>   \"Patricia Williams\"\n# => ]people = [\n  %{name: \"John\", active: true},\n  %{name: \"Patricia\", active: false}\n]\nfor %{active: true, name: name} <- people do\n  name\nend\n# => [\"John\"]"},{"path":"miscellaneous-features.html","id":"miscellaneous-features","chapter":"7 Miscellaneous Features","heading":"7 Miscellaneous Features","text":"","code":""},{"path":"miscellaneous-features.html","id":"sigils","chapter":"7 Miscellaneous Features","heading":"7.1 Sigils","text":"","code":""},{"path":"miscellaneous-features.html","id":"r-regular-expressions","chapter":"7 Miscellaneous Features","heading":"7.1.1 ~r: regular expressions","text":"","code":"iex > regex <- ~ r/foo|bar/\niex > \"foo\" <- ~regex\n#> true\niex > \"bat\" <- ~regex\n#> false"},{"path":"miscellaneous-features.html","id":"strings-char-lists-and-word-list-sigils","chapter":"7 Miscellaneous Features","heading":"7.1.2 Strings, char lists and word list sigils","text":"","code":""},{"path":"miscellaneous-features.html","id":"strings-1","chapter":"7 Miscellaneous Features","heading":"7.1.2.1 Strings","text":"~s sigil used generate strings, like double quotes . ~s sigil useful string contains double quotes:","code":"iex> ~s(this is a string with \"double\" quotes, not 'single' ones)\n#> \"this is a string with \\\"double\\\" quotes, not 'single' ones\""},{"path":"miscellaneous-features.html","id":"char-lists","chapter":"7 Miscellaneous Features","heading":"7.1.2.2 Char lists","text":"~c sigil useful generating char lists contain single quotes:","code":"iex> ~c(this is a char list containing 'single quotes')\n#> 'this is a char list containing \\'single quotes\\''"},{"path":"miscellaneous-features.html","id":"word-lists","chapter":"7 Miscellaneous Features","heading":"7.1.2.3 Word lists","text":"~w sigil used generate lists words (words just regular strings). Inside ~w sigil, words separated whitespace.~w sigil also accepts c, s modifiers (char lists, strings, atoms, respectively), specify data type elements resulting list:","code":"iex> ~w(foo bar bat)\n#> [\"foo\", \"bar\", \"bat\"]iex> ~w(foo bar bat)a\n#> [:foo, :bar, :bat]"},{"path":"miscellaneous-features.html","id":"calendar-sigils","chapter":"7 Miscellaneous Features","heading":"7.1.3 Calendar Sigils","text":"","code":""},{"path":"miscellaneous-features.html","id":"date","chapter":"7 Miscellaneous Features","heading":"7.1.3.1 Date","text":"%Date{} struct contains fields year, month, day, calendar. can create one using ~D sigil:","code":"iex> d = ~D[2019-10-31]\n#> ~D[2019-10-31]\niex> d.day\n#> 31"},{"path":"miscellaneous-features.html","id":"time","chapter":"7 Miscellaneous Features","heading":"7.1.3.2 Time","text":"%Time{} struct contains fields hour, minute, second, microsecond, calendar. can create one using ~T sigil:","code":"iex> t = ~T[23:00:07.0]\n#> ~T[23:00:07.0]\niex> t.second\n#> 7"},{"path":"miscellaneous-features.html","id":"custom-sigiils","chapter":"7 Miscellaneous Features","heading":"7.1.4 Custom Sigiils","text":"hinted beginning chapter, sigils Elixir extensible. fact, using sigil ~r/foo/equivalent calling sigil_r binary char list argument:can also provide sigils implementing functions follow sigil_{character} pattern. example, let’s implement ~sigil returns integer (optional n modifier make negative):Sigils can also used compile-time work help macros. example, regular expressions Elixir compiled efficient representation compilation source code, therefore skipping step runtime. ’re interested subject, recommend learn macros check sigils implemented Kernel module (sigil_* functions defined).","code":"iex> sigil_r(<<\"foo\">>, 'i')\n#> ~r\"foo\"iiex> defmodule MySigils do\n...>   def sigil_i(string, []), do: String.to_integer(string)\n...>   def sigil_i(string, [?n]), do: -String.to_integer(string)\n...> end\n\niex> import MySigils\niex> ~i(13)\n#> 13\niex> ~i(42)n\n#> -42"},{"path":"project-management-with-mix.html","id":"project-management-with-mix","chapter":"8 Project Management with Mix","heading":"8 Project Management with Mix","text":"","code":""},{"path":"phoenix-basics.html","id":"phoenix-basics","chapter":"9 Phoenix Basics","heading":"9 Phoenix Basics","text":"","code":""}]
